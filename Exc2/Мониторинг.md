## Мотивация:
1) обеспечить стабильность системы
2) выявление узких мест для предотвращения сбоев на ранних этапах
3) планирование ресурсов для наиболее эффективного горизонтального и вертикального масштабирования
4) мониторинг очереди в брокере сообщений
5) мониторить время отклика и количество ошибок для оптимизации

## Выбор подхода к мониторингу:
RED для мониторинга запросов, времени отклика и ошибок из-за возможности реализации механизма распределнной трассировки.
Это позволит отслеживать запрос во всех сервисах, увидеть, где он задерживается и найти потерянные заказы.

### Метрики, которые мы будем использовать:
Number of dead-letter-exchange letters in RabbitMQ - для контроля контроля отказов при обработке сообщений. ярлык: топик
Number of message in flight in RabbitMQ - для мониторинга нагрузки на слушателей. ярлык: топик
Number of requests (RPS) for internet shop API - для контроля нагрузки и прогнозирования перегрузок. ярлык: метод/эндпоинт
CPU % for MES API - для мониторинга нагрузки. ярлык: имя пода
Memory Utilisation for MES API - для контроля ресурсов памяти. ярлык: имя пода
Memory Utilisation for shop db instance - для контроля ресурсов памяти
Memory Utilisation for MES db instance - для контроля ресурсов памяти
Number of connections for shop db instance - для контроля кол-ва подключений к БД
Number of connections for MES db instance - для контроля кол-ва подключений к БД
Response time (latency) for shop API - для контроля нагрузки. ярлык: метод/эндпоинт
Response time (latency) for CRM API - для контроля нагрузки. ярлык: метод/эндпоинт
Response time (latency) for MES API - для контроля нагрузки. ярлык: метод/эндпоинт
Size of S3 storage - для контроля использования ресурсов хранилища
Size of shop db instance - для контроля использования ресурсов хранилища
Size of MES db instance - для контроля использования ресурсов хранилища
Number of HTTP 200 for shop API - для построения графика с соотношением 5xx в %. ярлык метод/эндпоинт
Number of HTTP 200 for CRM API - для построения графика с соотношением 5xx в %. ярлык метод/эндпоинт
Number of HTTP 200 for MES API - для построения графика с соотношением 5xx в %. ярлык метод/эндпоинт
Number of HTTP 500 for shop API - для построения графика с соотношением 5xx в %. ярлык метод/эндпоинт
Number of HTTP 500 for CRM API - для построения графика с соотношением 5xx в %. ярлык метод/эндпоинт
Number of HTTP 500 for MES API - для построения графика с соотношением 5xx в %. ярлык метод/эндпоинт
Number of simultanious sessions for shop API - для мониторинга пиковой нагрузки и планирования сценариев масштабирования
Number of simultanious sessions for CRM API - для мониторинга пиковой нагрузки и планирования сценариев масштабирования
Number of simultanious sessions for MES API - для мониторинга пиковой нагрузки и планирования сценариев масштабирования
Kb tranferred (received) for shop API - для контроля обмена данными и мэтчинга с другими метриками
Kb tranferred (received) for CRM API - для контроля обмена данными и мэтчинга с другими метриками
Kb tranferred (received) for MES API - для контроля обмена данными и мэтчинга с другими метриками
Kb provided (sent) for shop API - для контроля обмена данными и мэтчинга с другими метриками
Kb provided (sent) for CRM API - для контроля обмена данными и мэтчинга с другими метриками
Kb provided (sent) for MES API - для контроля обмена данными и мэтчинга с другими метриками

## План действий:
1. **Развернуть и настроить Prometheus**
    - Настроить конфигурацию `prometheus.yml` для сбора метрик с сервисов.
    - Подключить экспортеров для RabbitMQ, S3 и других систем.
    - Проверить корректность работы Prometheus (сбор и отображение метрик).

2. **Настроить Grafana**
    - Подключить Grafana к Prometheus как источник данных.
    - Настроить дашборды для:
        - Сервисов.
        - RabbitMQ.
        - S3 хранилища.
        - PostgreSQL (задержки запросов, количество подключений, ошибки).
        - Общих показателей системы (CPU, RAM, диски).

    - Настроить права доступа и роли для команды.

3. **Настроить метрики в сервисах и RabbitMQ для Prometheus**
    - Встроить поддержку метрик в сервисы с использованием библиотек.
    - Подключить RabbitMQ Exporter для сбора метрик (очереди, потребители, задержки).
    - Убедиться, что все метрики отображаются в Prometheus.

4. **Добавить метрики для S3-хранилища**
    - Настроить S3 Exporter или сторонние решения для сбора метрик.
    - Мониторить состояние бакетов (число объектов, скорость записи/чтения, задержки).
    - Проверить интеграцию с Prometheus и Grafana.

5. **Добавить метрики для MES/Shop PostgreSQL**
    - Использовать Postgres Exporter для сбора метрик:
        - Количество подключений.
        - Время выполнения запросов.
        - Использование индексов.
        - Ошибки и блокировки.

    - Проверить отображение в Prometheus и дашбордах Grafana.

6. **Настроить ELK для логов**
    - Развернуть Elasticsearch, Logstash и Kibana.
    - Настроить сбор логов из сервисов и RabbitMQ (например, с помощью Filebeat).
    - Настроить индексирование и фильтрацию логов для удобного поиска.
    - Создать базовые визуализации и дашборды в Kibana.

7. **Настроить PagerDuty для алертов**
    - Интегрировать Grafana и Prometheus с PagerDuty для отправки алертов.
    - Настроить правила алертов:
        - Высокий уровень использования CPU/RAM.
        - Проблемы с RabbitMQ (падение очередей, таймауты).
        - Ошибки в PostgreSQL (долгие блокировки, дэдлоки).
        - Ошибки доступа к S3.

    - Проверить алерты (например, с помощью эмуляции инцидентов).

8. **Описать документацию по дежурствам для команды**
    - Структурировать документацию:
        - **Общие инструкции**: Доступы, контакты, работа с системой мониторинга, типы инцидентов.
        - **Процесс дежурства**: Кто, когда и как несет ответственность.
        - **Инструкции по реагированию на инциденты**: Сценарии решения для RabbitMQ, PostgreSQL, S3, и связанного ПО.

    - Разместить документацию в общей wiki (например, Confluence или GitHub).

9. **Обертка над API Prometheus**
    - Создать сервис для упрощенного доступа к данным Prometheus:
        - Поддержка REST API (например, эндпоинты для получения самых популярных метрик или пользовательских запросов).
        - Документировать API для команды.

    - Настроить механизм кэширования для уменьшения нагрузки на Prometheus.
    - Оптимизировать долгие/частые запросы (например, через агрегации).